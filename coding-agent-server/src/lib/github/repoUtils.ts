import { execAsync } from '../../constants/repoIngest';
import octokit from '../Octokit';
import { runSandboxCommand } from '../sandbox/sandBoxUtils';



function extractRepoName(repoUrl: string): string {
    const match = repoUrl.match(/\/([^\/]+?)(\.git)?$/);
    if (!match) {
        throw new Error("Invalid repository URL");
    }
    return match[1];
}

function getAuthenticatedRepoUrl(repoUrl: string, token?: string): string {
    if (!token) return repoUrl;
    
    // Convert HTTPS URL to authenticated URL
    // https://github.com/user/repo.git -> https://token@github.com/user/repo.git
    const urlMatch = repoUrl.match(/^https:\/\/github\.com\/(.+)$/);
    if (urlMatch) {
        return `https://${token}@github.com/${urlMatch[1]}`;
    }
    
    return repoUrl;
}

export async function cloneRepoInSandbox(containerName: string, repoUrl: string, githubToken?: string) {
    const authUrl = getAuthenticatedRepoUrl(repoUrl, githubToken);
    await runSandboxCommand(containerName, `git clone ${authUrl}`)
    return extractRepoName(repoUrl); 
}

export async function createAndCheckoutBranch(containerName: string, branchName: string, repoName: string) {
    await runSandboxCommand(containerName, `cd ${repoName} && git checkout -b ${branchName}`)
}

export async function commitChange(containerName: string, message: string, repoName: string) {
    await runSandboxCommand(containerName, `cd ${repoName} && git config user.email "bot@ai-dev.com" && git config user.name "AI Dev Bot"`)
    await runSandboxCommand(containerName, `cd ${repoName} && git add .`);
    await runSandboxCommand(containerName, `cd ${repoName} && git commit -m "${message}"`)
}

export async function pushBranch(containerName: string, branchName: string, repoName: string, githubToken?: string, repoUrl?: string) {
    // Configure git credentials if token is provided
    if (githubToken) {
        // Store token as git credential
        await runSandboxCommand(containerName, `git config --global credential.helper store`);
        
        const credsFile = `echo "https://${githubToken}@github.com" > ~/.git-credentials`;
        await runSandboxCommand(containerName, credsFile);
    }
    
    // Update remote URL to authenticated version if we have both token and URL
    if (githubToken && repoUrl) {
        const authUrl = getAuthenticatedRepoUrl(repoUrl, githubToken);
        await runSandboxCommand(containerName, `cd ${repoName} && git remote set-url origin ${authUrl}`);
    }
    
    await runSandboxCommand(containerName, `cd ${repoName} && git push origin ${branchName}`)
}

export async function applyFileChanges(containerName: string, filePath: string, content: string, repoName: string) {
    const base64Content = Buffer.from(content).toString('base64');

    // Ensure the file path is relative to the repo directory
    const fullPath = `${repoName}/${filePath}`;

    const writeScript = `
      const fs = require('fs');
      const path = require('path');
      const target = '${fullPath}';
      const content = Buffer.from('${base64Content}', 'base64');
      fs.mkdirSync(path.dirname(target), { recursive: true });
      fs.writeFileSync(target, content);
    `;

    await execAsync(`docker exec -i ${containerName} node -e "${writeScript.replace(/\n/g, ' ')}"`);
}

export async function createPullRequest(
    repoUrl: string,
    branchName: string,
    githubToken?: string,
    title?: string,
    body?: string,
    base: string = 'main'
) {
    const regex = /github\.com\/([^\/]+)\/([^\/]+?)(\.git)?$/;
    const match = repoUrl.match(regex);

    if (!match) {
        throw new Error("Invalid GitHub repository URL");
    }

    const owner = match[1];
    const repo = match[2];

    // Use token-specific octokit instance
    const { createOctokit } = require('../Octokit');
    const octokitInstance = createOctokit(githubToken);

    try {
        const response = await octokitInstance.pulls.create({
            owner,
            repo,
            title: title || `Automated PR from Coding Agent - ${branchName}`,
            body: body || `This pull request was automatically generated by the Coding Agent for branch ${branchName}.`,
            head: branchName,
            base: base
        });

        return response.data.html_url;

    } catch (error: any) {
        if (error.status === 422 && error.message.includes("A pull request already exists")) {
            const existingPrs = await octokitInstance.pulls.list({
                owner,
                repo,
                head: `${owner}:${branchName}`,
                state: 'open'
            });

            if (existingPrs.data.length > 0) {
                return existingPrs.data[0].html_url;
            }
        }

        console.error("Failed to create PR:", error.message);
        throw new Error(`GitHub API Error: ${error.message}`);
    }
}
import { execAsync } from '../../constants/repoIngest';
import octokit, { createOctokit } from '../Octokit';
import { runSandboxCommand } from '../sandbox/sandBoxUtils';


function extractRepoName(repoUrl: string): string {
    const match = repoUrl.match(/\/([^\/]+?)(\.git)?$/);
    if (!match) {
        throw new Error("Invalid repository URL");
    }
    return match[1];
}

function getAuthenticatedRepoUrl(repoUrl: string, token?: string): string {
    if (!token) return repoUrl;
    
    // Convert HTTPS URL to authenticated URL
    // https://github.com/user/repo.git -> https://token@github.com/user/repo.git
    const urlMatch = repoUrl.match(/^https:\/\/github\.com\/(.+)$/);
    if (urlMatch) {
        return `https://${token}@github.com/${urlMatch[1]}`;
    }
    
    return repoUrl;
}

export async function cloneRepoInSandbox(containerName: string, repoUrl: string, githubToken?: string) {
    const authUrl = getAuthenticatedRepoUrl(repoUrl, githubToken);
    
    // 1. Clone
    await runSandboxCommand(containerName, `git clone ${authUrl}`);

    // 2. Configure Identity for repo (This prevents "Author identity unknown")
    const repoName = extractRepoName(repoUrl);
    await runSandboxCommand(containerName, `cd ${repoName} && git config user.email "agent@bot.com"`);
    await runSandboxCommand(containerName, `cd ${repoName} && git config user.name "Coding Agent"`);

    return repoName; 
}

export async function createAndCheckoutBranch(containerName: string, branchName: string, repoName: string) {
    await runSandboxCommand(containerName, `cd ${repoName} && git checkout -b ${branchName}`)
}

export async function commitChange(containerName: string, message: string, repoName: string) {
    await runSandboxCommand(containerName, `cd ${repoName} && git add .`);
    await runSandboxCommand(containerName, `cd ${repoName} && git commit -m "${message}"`);
}

export async function pushBranch(containerName: string, branchName: string, repoName: string, githubToken?: string) {
    if (!githubToken) {
        await runSandboxCommand(containerName, `cd ${repoName} && git push origin ${branchName}`);
        return;
    }

    const remoteUrl = await runSandboxCommand(containerName, `cd ${repoName} && git remote get-url origin`);
    
    // Parse remote URL to extract owner/repo (e.g., github.com/owner/repo.git or github.com/owner/repo)
    const match = remoteUrl.trim().match(/github\.com[\/:]([^\/]+)\/(.+?)(\.git)?$/);
    if (!match) throw new Error("Could not parse remote URL");
    
    const owner = match[1];
    const repo = match[2];
    
    // Configure git credential helper to use the token
    // Using 'x-access-token' as username is a GitHub-recommended approach for tokens
    const authUrl = `https://x-access-token:${githubToken}@github.com/${owner}/${repo}.git`;
    
    // Store credentials temporarily in git config for this operation
    await runSandboxCommand(containerName, `cd ${repoName} && git config credential.helper store`);
    
    // Push using authenticated URL
    await runSandboxCommand(containerName, `cd ${repoName} && git push "${authUrl}" ${branchName}`);
}

export async function applyFileChanges(containerName: string, filePath: string, content: string, repoName: string) {
    const base64Content = Buffer.from(content).toString('base64');

    const fullPath = `${repoName}/${filePath}`;

    const writeScript = `
      const fs = require('fs');
      const path = require('path');
      const target = '${fullPath}';
      const content = Buffer.from('${base64Content}', 'base64');
      fs.mkdirSync(path.dirname(target), { recursive: true });
      fs.writeFileSync(target, content);
    `;

    await execAsync(`docker exec -i ${containerName} node -e "${writeScript.replace(/\n/g, ' ')}"`);
}

export async function createPullRequest(
    repoUrl: string,
    branchName: string,
    githubToken?: string,
    title?: string,
    body?: string,
    base?: string
) {
    const regex = /github\.com\/([^\/]+)\/([^\/]+?)(\.git)?$/;
    const match = repoUrl.match(regex);

    if (!match) {
        throw new Error("Invalid GitHub repository URL");
    }

    const owner = match[1];
    const repo = match[2];

    const octokitInstance = createOctokit(githubToken);

    try {
        // If base branch not provided, fetch the default branch from GitHub
        if (!base) {
            const repoData = await octokitInstance.repos.get({
                owner,
                repo
            });
            base = repoData.data.default_branch;
        }

        const response = await octokitInstance.pulls.create({
            owner,
            repo,
            title: title || `Automated PR from Coding Agent - ${branchName}`,
            body: body || `This pull request was automatically generated by the Coding Agent for branch ${branchName}.`,
            head: branchName,
            base: base
        });

        return response.data.html_url;

    } catch (error: any) {
        if (error.status === 422 && error.message.includes("A pull request already exists")) {
            const existingPrs = await octokitInstance.pulls.list({
                owner,
                repo,
                head: `${owner}:${branchName}`,
                state: 'open'
            });

            if (existingPrs.data.length > 0) {
                return existingPrs.data[0].html_url;
            }
        }

        console.error("Failed to create PR:", error.message);
        throw new Error(`GitHub API Error: ${error.message}`);
    }
}